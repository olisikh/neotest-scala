# munit

munit is a modern, opinionated testing library from the ScalaMeta team with ScalaTest-style syntax.

## Official Documentation

- Website: [scalameta.org/munit](https://scalameta.org/munit/)
- Getting Started: [scalameta.org/munit/docs/getting-started.html](https://scalameta.org/munit/docs/getting-started.html)

## Setup

### build.sbt

```scala
libraryDependencies += "org.scalameta" %% "munit" % "1.0.0" % Test
```

### Ecosystem Suites

munit is often used through ecosystem base suites that still expose `test("...")`:

- `CatsEffectSuite` (`munit-cats-effect`)
- `ScalaCheckSuite` (`munit-scalacheck`)
- `DisciplineSuite` (`discipline-munit`)
- `ZSuite` / `ZIOSuite` (`munit-zio`)

## Basic Usage

```scala
class MySuite extends munit.FunSuite {
  test("addition works") {
    assertEquals(1 + 1, 2)
  }

  test("string operations") {
    val str = "hello"
    assertEquals(str.length, 5)
    assert(str.startsWith("he"))
  }
}
```

## Test Discovery

The following munit-style test declarations are detected by Treesitter:

- `test("name") { ... }`
- `property("name") { ... }`
- `testZ("name") { ... }`

For standard munit and common ecosystem suites (`CatsEffectSuite`, `ScalaCheckSuite`, `DisciplineSuite`, `ZSuite`/`ZIOSuite`):

```scala
class MySuite extends munit.FunSuite {
  test("my test") {        // ✅ Detected
    // test body
  }
}
```

## Test Commands

### Run All Tests in Class

```bash
sbt <project>/testOnly com.example.MySuite
```

### Run Single Test

```bash
sbt <project>/testOnly -- "com.example.MySuite.addition works"
```

munit uses a hierarchical test path selector for running individual tests.

### Build Tool Notes

- `sbt`: single-test execution uses the full hierarchical selector (`Suite.test`).
- `bloop`: single-test requests run at suite scope (`--only com.example.MySuite`) and results are mapped back to the selected test from stdout/JUnit metadata.
- If bloop reports `No test suites were run.`, neotest-scala marks the run as failed (not passed).

## Features

### Assertions

```scala
class AssertionSuite extends munit.FunSuite {
  test("assertions") {
    // Equality
    assertEquals(1 + 1, 2)
    
    // Boolean
    assert(true)
    assert(!false)
    
    // Double with tolerance
    assertDoubleEquals(1.0, 1.0, 0.001)
    
    // Type checking
    assertTypeEquals(1, 2)  // Compiles only if same type
  }
}
```

### Fixtures

```scala
class FixtureSuite extends munit.FunSuite {
  var tempFile: java.io.File = _
  
  override def beforeEach(context: BeforeEach): Unit = {
    tempFile = java.io.File.createTempFile("test", ".tmp")
  }
  
  override def afterEach(context: AfterEach): Unit = {
    tempFile.delete()
  }
  
  test("use temp file") {
    assert(tempFile.exists())
  }
}
```

### Async Tests

```scala
import scala.concurrent.Future
import munit.FunSuite

class AsyncSuite extends FunSuite {
  test("async operation") {
    Future {
      1 + 1
    }.map { result =>
      assertEquals(result, 2)
    }
  }
}
```

## Debugging

munit supports debugging individual tests:

```lua
require('neotest').run.run({ strategy = 'dap' })
```

See [[Debugging]] for setup instructions.

## Test Path Building

neotest-scala builds hierarchical test paths for munit:

| Context | Test Path |
|---------|-----------|
| File | `package.*` |
| Namespace (class) | `package.ClassName` |
| Test | `package.ClassName.test name` |
| Nested test | `package.ClassName.parent name.test name` |

For munit + bloop single-test runs, neotest-scala intentionally uses `package.ClassName` (suite scope) to avoid selector mismatches.

## Limitations

- Nested test suites (tests within tests) are supported but path building may be complex
- `bloop` result parsing is best-effort compared to JUnit XML (used by `sbt`)

## Related Pages

- [[Supported Test Libraries|3.-Supported-Test-Libraries]] — All libraries overview
- [[Debugging]] — Debugging setup
- [[Configuration|2.-Configuration]] — Configuration options
