# Suite Type Coverage (Gaps + Complexity)

This page is a gap analysis of which *suite styles* (and common test-definition shapes) are currently supported for the libraries that `neotest-scala` supports, and what is still missing.

## How The Adapter Works (Relevant Bits)

- **Discovery**: framework modules in `lua/neotest-scala/framework/*/init.lua` use Treesitter queries (and, for specs2 TextSpec, a custom parser) to build neotest positions.
- **Build tool**: commands are built via `lua/neotest-scala/build.lua`. Tool selection is pinned into `spec.env.build_tool`.
- **Results**:
  - If `spec.env.build_tool == "bloop"`, results come from `framework.parse_stdout_results(output, tree)`.
  - Otherwise, results come from JUnit XML in `target/test-reports/` via `framework.build_namespace(...)` + `framework.build_position_result(...)`.
  - Some frameworks are **forced to sbt** even when the selected tool is `bloop` (see `build.enforce_framework_tool`).

Complexity in this doc is relative to the current codebase and patterns already implemented.

## ScalaTest

### Currently Detected

Detection is gated by `extends` checks in `lua/neotest-scala/framework/scalatest/init.lua`:

- `AnyFunSuite` / `*FunSuite`
- `AnyFreeSpec` / `*FreeSpec`
- `AnyFlatSpec` / `*FlatSpec`

And then these syntaxes are discovered:

- FunSuite: `test("name") { ... }`
- FreeSpec: `"context" - { ... }` and `"test" in { ... }` (with nesting)
- FlatSpec: `"subject" should "do X" in { ... }` and `it should "do X" in { ... }`

### Popular Suite Types Currently Missing (Within ZIO 2 Scope)

These are common in real-world ScalaTest codebases, but will not be discovered today because `detect_style` does not recognize them:

- **AnyWordSpec / AnyWordSpecLike**
  - Typical syntax: `"A Stack" should { "pop" in { ... } }`
  - Missing pieces: style detection + dedicated Treesitter query for the nested `"..." should { ... }` structure.
- **AnyFunSpec / AnyFunSpecLike**
  - Typical syntax: `describe("A Stack") { it("pops") { ... } }`
  - Missing pieces: style detection + Treesitter query for `describe`/`it`.
- **AnyFeatureSpec / AnyFeatureSpecLike**
  - Typical syntax: `Feature("X") { Scenario("Y") { ... } }`
  - Missing pieces: style detection + Treesitter query for `Feature`/`Scenario`.
- **AnyPropSpec / AnyPropSpecLike**
  - Typical syntax: `property("...") { ... }`
  - Missing pieces: style detection + Treesitter query for `property`.
- **AnyRefSpec / RefSpec-like styles**
  - Typical syntax: often string + `in`/`is` patterns, depending on style
  - Missing pieces: style detection + query (likely needs its own pass).
- **Async* suites** (e.g. `AsyncFunSuite`, `AsyncFreeSpec`, `AsyncFlatSpec`, `AsyncWordSpec`, `AsyncFunSpec`)
  - Most share the same surface test-definition syntax but are different base classes.
  - Missing pieces: style detection; discovery queries may be reusable once detection works.
- **Fixture* suites** (e.g. `FixtureAnyFunSuite`, `FixtureAnyFlatSpec`, etc.)
  - Often the same DSL but different base types; sometimes test bodies take fixture params.
  - Missing pieces: style detection (discovery likely still works once detected).

### Complexity Assessment

- **Low**: add style detection for additional base classes where the DSL is identical to already-supported ones (many Async*/Fixture* variants).
- **Medium**: AnyPropSpec (usually a simple `property("name")` call pattern, but matching results can still be tricky for name normalization).
- **High**: AnyFunSpec / AnyWordSpec / AnyFeatureSpec.
  - Discovery needs new Treesitter queries.
  - Single-test running may need a “full path” builder similar to the existing FreeSpec parent-context path logic (depending on how ScalaTest names nested tests in JUnit and/or stdout).

## munit

### Currently Detected

Detection in `lua/neotest-scala/framework/munit/init.lua` is currently narrow:

- `extends FunSuite` or `extends munit.FunSuite`
- Test syntax: `test("name") { ... }`

### Popular Suite Types Currently Missing

In practice, many munit users extend community suites rather than `FunSuite` directly:

- **Cats Effect**: `CatsEffectSuite` (munit-cats-effect)
- **ScalaCheck**: `ScalaCheckSuite` (munit-scalacheck)
- **Discipline**: `DisciplineSuite` (munit-discipline)
- **ZIO**: `ZSuite` / `ZIOSuite` (munit-zio)

These generally still use `test("name")`, so the *query* can stay the same; the *detection gate* is what tends to break.

### Complexity Assessment

- **Low**: broaden detection to recognize common `extends XSuite` variants (or a safer “munit import + test("...")” heuristic).
- **Medium**: improve stdout parsing robustness for variants that change output formatting under `bloop` (if encountered).

## specs2

### Currently Detected

Detection in `lua/neotest-scala/framework/specs2/init.lua`:

- “TextSpec” via `s2""" ... """` (custom parser in `lua/neotest-scala/framework/specs2/textspec.lua`)
- “Mutable-ish” via `extends Specification` with infix patterns like:
  - `"name" >> { ... }`
  - `"name" in { ... }`

### Popular Suite Types / Shapes Currently Missing

specs2 has many ways to express examples/fragments; the current implementation covers only a subset:

- **TextSpec blocks without `$ref` lines**
  - Current TextSpec parsing only extracts lines that end with `$something` references.
  - Inline examples in `s2""" ... """` without refs will not produce test positions.
- **`!` / fragments-based syntax**
  - Many specs2 examples are written as `"name" ! ok` or assembled from fragments.
  - Missing pieces: new parsing strategy (Treesitter-only may be insufficient; may need a second custom parser).
- **Immutable `Specification` variants**
  - Some projects rely on immutable `Specification` styles rather than mutable; the syntax coverage is not guaranteed with the current infix query.

### Complexity Assessment

- **Medium**: extend TextSpec parsing to support more in-block patterns (if a clear heuristic exists).
- **High**: robust support for fragments-based / `!`-operator specs (likely needs a purpose-built parser and improved result matching).

## utest

### Currently Detected

Detection in `lua/neotest-scala/framework/utest/init.lua` is relatively permissive and targets:

- `object/class ... extends TestSuite` (and a broad `utest` marker)
- `test("name") { ... }` (including nested `test("outer") { test("inner") { ... } }`)

### Common Missing Shapes

- **Non-literal test names**:
  - `test(s"computed $name") { ... }` or `test(nameVar) { ... }`
  - Current Treesitter queries only match literal `(string)` nodes.
  - Even if discovered, result matching can be unreliable because the runtime name is not trivially recoverable.

### Complexity Assessment

- **Low**: more robust namespace detection if users define suites in unconventional structures.
- **High**: supporting non-literal test names in a way that still round-trips to runner output/JUnit IDs.

## zio-test

### Currently Detected

Detection in `lua/neotest-scala/framework/zio-test/init.lua` looks for:

- `extends ZIOSpecDefault` or a `zio.test` marker
- Calls to `test("name")`, `suite("name")`, `suiteAll("name")`

### Popular Suite Types Currently Missing

- **Alternative base traits**
  - Some ZIO 2 codebases use different base traits or wiring patterns than `ZIOSpecDefault`.

### Complexity Assessment

- **Medium**: broaden detection for additional ZIO 2 base traits when the DSL is still `test/suite`.
- **Out of scope**: ZIO 1.x compatibility.

## Cross-Cutting Gaps (Affect Multiple Frameworks)

These aren’t “suite types” per se, but they are common in real code and currently reduce discovery/matching quality:

- **Interpolated/non-literal test names** (`s"..."`, `nameVar`, concatenation)
  - Discovery may be possible, but result matching is hard because names are runtime-evaluated.
- **Generated tests** (loops, property-based generators producing dynamic names)
  - Typically not reliably discoverable statically without executing code.
- **Nested test-path fidelity**
  - Some styles require reconstructing a full hierarchical path for single-test runs (FreeSpec already needed special handling).

## Suggested Implementation Order (Most Value per Effort)

1. **munit: broaden suite detection** (CatsEffectSuite / ScalaCheckSuite / DisciplineSuite).
2. **ScalaTest: add Async*/Fixture* detection** (reuses existing queries).
3. **ScalaTest: implement AnyPropSpec** (new but fairly localized query).
4. **ScalaTest: implement AnyFunSpec / AnyWordSpec / AnyFeatureSpec** (bigger DSL work + likely path-building).
5. **specs2: expand beyond current TextSpec + mutable subset** (parser work; higher risk).
